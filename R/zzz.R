# ==================================================================== #
# TITLE                                                                #
# AMR: An R Package for Working with Antimicrobial Resistance Data     #
#                                                                      #
# SOURCE                                                               #
# https://github.com/msberends/AMR                                     #
#                                                                      #
# CITE AS                                                              #
# Berends MS, Luz CF, Friedrich AW, Sinha BNM, Albers CJ, Glasner C    #
# (2022). AMR: An R Package for Working with Antimicrobial Resistance  #
# Data. Journal of Statistical Software, 104(3), 1-31.                 #
# doi:10.18637/jss.v104.i03                                            #
#                                                                      #
# Developed at the University of Groningen, the Netherlands, in        #
# collaboration with non-profit organisations Certe Medical            #
# Diagnostics & Advice, and University Medical Center Groningen.       #
#                                                                      #
# This R package is free software; you can freely use and distribute   #
# it for both personal and commercial purposes under the terms of the  #
# GNU General Public License version 2.0 (GNU GPL-2), as published by  #
# the Free Software Foundation.                                        #
# We created this package for both routine data analysis and academic  #
# research and it was publicly released in the hope that it will be    #
# useful, but it comes WITHOUT ANY WARRANTY OR LIABILITY.              #
#                                                                      #
# Visit our website for the full manual and a complete tutorial about  #
# how to conduct AMR data analysis: https://msberends.github.io/AMR/   #
# ==================================================================== #

# set up package environment, used by numerous AMR functions
AMR_env <- new.env(hash = FALSE)
AMR_env$mo_uncertainties <- data.frame(
  original_input = character(0),
  input = character(0),
  fullname = character(0),
  mo = character(0),
  candidates = character(0),
  minimum_matching_score = integer(0),
  keep_synonyms = logical(0),
  stringsAsFactors = FALSE
)
AMR_env$mo_renamed <- list()
AMR_env$mo_previously_coerced <- data.frame(
  x = character(0),
  mo = character(0),
  stringsAsFactors = FALSE
)
AMR_env$rsi_interpretation_history <- data.frame(
  datetime = Sys.time()[0],
  index = integer(0),
  ab_input = character(0),
  ab_considered = character(0),
  mo_input = character(0),
  mo_considered = character(0),
  guideline = character(0),
  ref_table = character(0),
  method = character(0),
  breakpoint_S = double(0),
  breakpoint_R = double(0),
  input = double(0),
  interpretation = character(0),
  stringsAsFactors = FALSE
)
AMR_env$has_data.table <- pkg_is_available("data.table", also_load = FALSE)

# determine info icon for messages
utf8_supported <- isTRUE(base::l10n_info()$`UTF-8`)
is_latex <- tryCatch(import_fn("is_latex_output", "knitr", error_on_fail = FALSE)(),
  error = function(e) FALSE
)
if (utf8_supported && !is_latex) {
  # \u2139 is a symbol officially named 'information source'
  AMR_env$info_icon <- "\u2139"
} else {
  AMR_env$info_icon <- "i"
}

.onLoad <- function(lib, pkg) {
  # Support for tibble headers (type_sum) and tibble columns content (pillar_shaft)
  # without the need to depend on other packages. This was suggested by the
  # developers of the vctrs package:
  # https://github.com/r-lib/vctrs/blob/05968ce8e669f73213e3e894b5f4424af4f46316/R/register-s3.R
  s3_register("pillar::pillar_shaft", "ab")
  s3_register("pillar::pillar_shaft", "mo")
  s3_register("pillar::pillar_shaft", "rsi")
  s3_register("pillar::pillar_shaft", "mic")
  s3_register("pillar::pillar_shaft", "disk")
  s3_register("tibble::type_sum", "ab")
  s3_register("tibble::type_sum", "mo")
  s3_register("tibble::type_sum", "rsi")
  s3_register("tibble::type_sum", "mic")
  s3_register("tibble::type_sum", "disk")
  # Support for frequency tables from the cleaner package
  s3_register("cleaner::freq", "mo")
  s3_register("cleaner::freq", "rsi")
  # Support for skim() from the skimr package
  if (pkg_is_available("skimr", also_load = FALSE, min_version = "2.0.0")) {
    s3_register("skimr::get_skimmers", "mo")
    s3_register("skimr::get_skimmers", "rsi")
    s3_register("skimr::get_skimmers", "mic")
    s3_register("skimr::get_skimmers", "disk")
  }
  # Support for autoplot() from the ggplot2 package
  s3_register("ggplot2::autoplot", "rsi")
  s3_register("ggplot2::autoplot", "mic")
  s3_register("ggplot2::autoplot", "disk")
  s3_register("ggplot2::autoplot", "resistance_predict")
  # Support for fortify from the ggplot2 package
  s3_register("ggplot2::fortify", "rsi")
  s3_register("ggplot2::fortify", "mic")
  s3_register("ggplot2::fortify", "disk")
  # Support vctrs package for use in e.g. dplyr verbs
  s3_register("vctrs::vec_ptype2", "ab.character")
  s3_register("vctrs::vec_ptype2", "character.ab")
  s3_register("vctrs::vec_cast", "character.ab")
  s3_register("vctrs::vec_ptype2", "mo.character")
  s3_register("vctrs::vec_ptype2", "character.mo")
  s3_register("vctrs::vec_cast", "character.mo")
  s3_register("vctrs::vec_ptype2", "ab_selector.character")
  s3_register("vctrs::vec_ptype2", "character.ab_selector")
  s3_register("vctrs::vec_cast", "character.ab_selector")
  s3_register("vctrs::vec_ptype2", "ab_selector_any_all.logical")
  s3_register("vctrs::vec_ptype2", "logical.ab_selector_any_all")
  s3_register("vctrs::vec_cast", "logical.ab_selector_any_all")
  s3_register("vctrs::vec_ptype2", "disk.integer")
  s3_register("vctrs::vec_ptype2", "integer.disk")
  s3_register("vctrs::vec_cast", "integer.disk")
  s3_register("vctrs::vec_cast", "character.mic")
  s3_register("vctrs::vec_cast", "double.mic")
  s3_register("vctrs::vec_math", "mic")

  # if mo source exists, fire it up (see mo_source())
  if (tryCatch(file.exists(getOption("AMR_mo_source", "~/mo_source.rds")), error = function(e) FALSE)) {
    invisible(get_mo_source())
  }

  # be sure to print tibbles as tibbles
  if (pkg_is_available("tibble", also_load = FALSE)) {
    loadNamespace("tibble")
  }

  # reference data - they have additional columns compared to `antibiotics` and `microorganisms` to improve speed
  # they cannot be part of R/sysdata.rda since CRAN thinks it would make the package too large (+3 MB)
  assign(x = "AB_lookup", value = create_AB_lookup(), envir = asNamespace("AMR"))
  assign(x = "MO_lookup", value = create_MO_lookup(), envir = asNamespace("AMR"))
  # for mo_is_intrinsic_resistant() - saves a lot of time when executed on this vector
  assign(x = "INTRINSIC_R", value = create_intr_resistance(), envir = asNamespace("AMR"))
}

# Helper functions --------------------------------------------------------

create_AB_lookup <- function() {
  cbind(AMR::antibiotics, AB_LOOKUP)
}

create_MO_lookup <- function() {
  MO_lookup <- AMR::microorganisms

  MO_lookup$kingdom_index <- NA_real_
  MO_lookup[which(MO_lookup$kingdom == "Bacteria" | MO_lookup$mo == "UNKNOWN"), "kingdom_index"] <- 1
  MO_lookup[which(MO_lookup$kingdom == "Fungi"), "kingdom_index"] <- 2
  MO_lookup[which(MO_lookup$kingdom == "Protozoa"), "kingdom_index"] <- 3
  MO_lookup[which(MO_lookup$kingdom == "Archaea"), "kingdom_index"] <- 4
  # all the rest
  MO_lookup[which(is.na(MO_lookup$kingdom_index)), "kingdom_index"] <- 5

  # # use this paste instead of `fullname` to work with Viridans Group Streptococci, etc.
  # if (length(MO_FULLNAME_LOWER) == nrow(MO_lookup)) {
  #   MO_lookup$fullname_lower <- MO_FULLNAME_LOWER
  # } else {
  #   MO_lookup$fullname_lower <- ""
  #   warning("MO table updated - Run: source(\"data-raw/_pre_commit_hook.R\")", call. = FALSE)
  # }

  MO_lookup$fullname_lower <- create_MO_fullname_lower()
  MO_lookup$full_first <- substr(MO_lookup$fullname_lower, 1, 1)
  MO_lookup$species_first <- substr(MO_lookup$species, 1, 1)

  # so arrange data on prevalence first, then kingdom, then full name
  MO_lookup[order(MO_lookup$prevalence, MO_lookup$kingdom_index, MO_lookup$fullname_lower), , drop = FALSE]
}

create_MO_fullname_lower <- function() {
  MO_lookup <- AMR::microorganisms
  # use this paste instead of `fullname` to work with Viridans Group Streptococci, etc.
  MO_lookup$fullname_lower <- tolower(trimws(paste(
    MO_lookup$genus,
    MO_lookup$species,
    MO_lookup$subspecies
  )))
  ind <- MO_lookup$genus == "" | grepl("^[(]unknown ", MO_lookup$fullname, perl = TRUE)
  MO_lookup[ind, "fullname_lower"] <- tolower(MO_lookup[ind, "fullname", drop = TRUE])
  MO_lookup$fullname_lower <- trimws(gsub("[^.a-z0-9/ \\-]+", "", MO_lookup$fullname_lower, perl = TRUE))
  MO_lookup$fullname_lower
}

create_intr_resistance <- function() {
  # for mo_is_intrinsic_resistant() - saves a lot of time when executed on this vector
  paste(AMR::intrinsic_resistant$mo, AMR::intrinsic_resistant$ab)
}
